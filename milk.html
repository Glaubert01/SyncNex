<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SyncNex - CSN</title>
  <link rel="stylesheet" href="style.css" />
  <link rel="icon" type="image/png" href="assets/syncnex-favicon.png">
  <style>
    html, body { height: 100%; margin: 0; padding: 0; font-family: Roboto, Arial, sans-serif; }
    #map { width: 100vw; height: 100vh; position: absolute; left: 200px; top: 0; z-index: 1; }
    .custom-controls {
      position: absolute; top: 10px; left: 500px; z-index: 5; display: flex; gap: 12px; flex-wrap: wrap; align-items: center;
    }
    .custom-controls button, .custom-controls input[type="color"], .custom-controls label {
      padding: 8px 13px; background: #fff; border: 1px solid #ddd; border-radius: 4px;
      font-size: 1rem; cursor: pointer; font-weight: bold; box-shadow: 0 2px 6px #0001;
      transition: background .2s;
    }
    .custom-controls label { display:flex; align-items:center; gap:8px; font-weight:500; cursor: pointer; }
    .custom-controls input[type="checkbox"]{ transform: scale(1.2); cursor:pointer; }
    .custom-controls button.active, .custom-controls button:hover { background: #e8e8e8; }
    .color-picker { display: flex; align-items: center; gap: 4px; }
    .color-circle { width: 24px; height: 24px; border-radius: 50%; border: 2px solid #ddd; cursor: pointer; margin-right: 2px; display: inline-block; }
    .color-circle.selected { border: 3px solid #2196f3; }
    .timer-bar { position: fixed; right: 0; top: 0; font-size: 14px; color: #444; z-index: 10; background: #fafafadb; padding: 2px 8px; border-radius: 0 0 8px 8px; border-bottom: 1px solid #ddd; }
    .custom-label-box { background: #fff; border-radius: 12px; padding: 6px 16px 14px 16px; box-shadow: 0 2px 10px #0002; border: 1px solid #eee; position: relative; min-width: 80px; display: flex; flex-direction: column; align-items: center; font-size: 1rem; }
    .custom-label-box .delete-area-btn { position: absolute; top: 2px; right: 7px; color: #b21c1c; background: transparent; border: none; font-size: 22px; cursor: pointer; font-weight: bold; }
    .custom-label-box .area-title { margin-top: 8px; margin-bottom: 3px; font-size: 1.05rem; font-weight: 600; background: #e9f7fa; padding: 3px 10px; border-radius: 6px; border: 1px solid #b8d0db; color: #118; display: inline-block; }
    .custom-label-box .area-parent { font-size: 0.9em; color: #757575; margin-top: 2px; }
    .footer { position: fixed; left: 0; bottom: 0; width: 100vw; z-index: 99; background: rgba(10,16,30,0.94); box-shadow: 0 -4px 24px #0003; color: #fff; }
    .sidebar { z-index: 20; display: block !important; }

    .modal-bg { display:none; position:fixed; z-index:1001; left:0;top:0;width:100vw;height:100vh; background:rgba(0,0,0,0.24); align-items:center; justify-content:center; }
    .modal { background: #fff; border-radius: 10px; padding: 24px 20px 20px 20px; min-width:340px; box-shadow: 0 8px 40px #0005; position:relative; color: #000; max-height: 80vh; overflow:auto; }
    .modal h3 { margin-top:0; }
    .modal-close { position:absolute; top:12px; right:18px; font-size:20px; background:none; border:none; color:#b21c1c; cursor:pointer;}
    .modal label {display:block; margin: 10px 0 4px 0; font-weight:500;}
    .modal select, .modal input[type="text"] { width:90%; font-size:1rem; padding:6px 8px;}

    .drag-list { list-style: none; padding: 0; margin: 8px 0; }
    .drag-item { display: flex; align-items: center; justify-content: space-between; gap: 10px; padding: 10px 12px; border: 1px solid #e1e1e1; border-radius: 8px; background: #fff; margin-bottom: 8px; cursor: grab; }
    .drag-item:active { cursor: grabbing; }
    .drag-item .left { display: flex; align-items: center; gap: 10px; }
    .handle { font-size: 18px; user-select: none; }
    .pill { background:#eef4ff; border:1px solid #cddfff; padding:2px 8px; border-radius:999px; font-size:.9em; color:#23488b; }
    .pill-ok { background:#e6f7ec; border:1px solid #bfe7c9; color:#256c30; }
    .danger-btn { background:#c32c2c; color:#fff; padding:6px 10px; border:none; border-radius:6px; cursor:pointer; }
    .ok-btn { background:#2196f3; color:#fff; padding:8px 18px; border:none; border-radius:6px; cursor:pointer; font-weight:bold; }

    #modalVersaoBg { display:none; position: fixed; z-index: 2000; left: 0; top: 0; width: 100vw; height: 100vh; background: rgba(0,0,0,0.24); align-items: center; justify-content: center; }
    #modalVersao { background: #fff; border-radius: 10px; padding: 26px 28px 20px 28px; min-width:340px; box-shadow: 0 8px 40px #0005; position: relative; color: #222; animation: fadeIn .18s; max-width: 94vw; }
    #modalVersao h3 { margin-top:0; color: #23488b; font-size: 1.25em;}
    #modalVersao ul { margin-top: 10px; padding-left: 22px; font-size: 1.04em;}
    #modalVersao .modal-close { position: absolute; top: 10px; right: 14px; font-size: 23px; background: none; border: none; color: #b21c1c; cursor: pointer;}
    @keyframes fadeIn { from { opacity: 0; transform: scale(0.96);} to { opacity: 1; transform: scale(1);} }
    .footer .versao-btn { border: none; outline: none; background: none; font: inherit; color: inherit; cursor: pointer; border-radius: 30px; padding: 4px 16px; transition: background 0.15s; font-size: 1em; margin-left: 12px; display: inline-block; }
    .footer .versao-btn:active, .footer .versao-btn:hover { background: #212638; color: #ffda48; box-shadow: 0 0 4px #0072ce30; }
    .versao-btn b { color: #ffe050;} .versao-btn .vnum { color: #6ca3ff; font-weight: 600;}
  </style>
</head>
<body>
  <button id="toggle-mode" class="darkmode-btn" title="Alternar modo escuro">🌓</button>
  <button class="menu-toggle" id="menu-toggle" aria-label="Abrir menu">&#9776;</button>
  <div class="container">
    <aside class="sidebar" id="sidebar">
      <a href="index.html"><img src="/assets/logo-csn.png" alt="Logo CSN" class="logo-csn" /></a>
      <ul class="menu">
        <li><a href="absenteismo.html">Absenteismo</a></li>
        <li><a href="contratos.html">Contratos</a></li>
        <li><a href="dgfm.html">DGFM</a></li>
        <li><a href="diesel.html">Diesel</a></li>
        <li><a href="efetivo.html">Efetivo</a></li>
        <li><a href="horaextra.html">Horas Extras</a></li>
        <li><a href="kanban.html">Kanban</a></li>
        <li class="menu__item"><a href="mapa.html">Mapa</a></li>
        <li><a href="mttr.html">MTTR</a></li>
        <li><a href="mtbf.html">MTBF</a></li>
        <li class="menu__item"><a href="organograma.html">Organograma</a></li>
        <li><a href="projetos.html">Projetos</a></li>
        <li><a href="sobressalentes.html">Sobressalentes</a></li>
      </ul>
    </aside>
  </div>

  <div class="timer-bar" id="timerBar">Próxima atualização em: <span id="timerValue">01:00</span></div>

  <div class="custom-controls">
    <div class="color-picker" title="Escolher cor da área">
      <div class="color-circle" data-color="#2196f3" style="background:#2196f3;"></div>
      <div class="color-circle" data-color="#43a047" style="background:#43a047;"></div>
      <div class="color-circle" data-color="#ff9800" style="background:#ff9800;"></div>
      <div class="color-circle" data-color="#e53935" style="background:#e53935;"></div>
      <input type="color" id="customColor" value="#2196f3" style="width:34px;height:26px;">
    </div>
    <button id="drawAreaBtn">Desenhar Área</button>
    <button id="clearBtn">Limpar Áreas</button>
    <button id="incluirPlacaBtn" style="background:#2969b0; color:#fff;">Incluir Placa</button>
    <button id="gerenciarOrdemBtn" style="background:#5c6bc0; color:#fff;">Gerenciar Entregas</button>

    <!-- NOVO: Rotas por ruas -->
    <label title="Usar menor distância entre as paradas (Google otimiza a ordem)">
      <input type="checkbox" id="optimizeChk"> Otimizar rota
    </label>
  </div>

  <div id="map"></div>

  <!-- Modal: Incluir Placa -->
  <div class="modal-bg" id="modalPlaca">
    <div class="modal">
      <button class="modal-close" onclick="closeModalPlaca()">&times;</button>
      <h3>Nova Placa de Entrega</h3>
      <form id="placaForm" autocomplete="off">
        <label>Placa</label>
        <input id="placaInput" type="text" placeholder="ABC1D23" required />
        <label>Geoárea</label>
        <select id="areaPlaca" required><option value="">Selecione...</option></select>
        <label>Status</label>
        <select id="statusPlaca" required>
          <option>Aguardando carregamento</option>
          <option>Carregado</option>
          <option>Em Rota</option>
          <option>Entregue</option>
        </select>
        <div style="margin-top:15px;">
          <button type="submit" class="ok-btn">Salvar</button>
        </div>
      </form>
    </div>
  </div>

  <!-- Modal: Gerenciar (drag & drop + status) -->
  <div class="modal-bg" id="modalGestao">
    <div class="modal" style="min-width:520px;">
      <button class="modal-close" onclick="closeModalGestao()">&times;</button>
      <h3>Entregas (arraste para reordenar)</h3>
      <ul id="entregasList" class="drag-list"></ul>
      <div style="margin-top:10px; display:flex; gap:10px; justify-content:flex-end;">
        <button class="ok-btn" onclick="salvarReordenacao()">Concluir</button>
      </div>
    </div>
  </div>

  <!-- Modal Versão -->
  <div class="modal-bg" id="modalVersaoBg">
    <div id="modalVersao">
      <button class="modal-close" onclick="document.getElementById('modalVersaoBg').style.display='none'">&times;</button>
      <h3>SyncNex <span style="font-weight: 400;color:#6ca3ff;">V1.4.0 (Release date: 13/08/25)</span></h3>
      <ul>
        <li>Rota pelas ruas com Directions API (exclui entregues).</li>
        <li>Otimização opcional da ordem (menor distância).</li>
        <li>Numeração dos pins segue a rota atual (visual).</li>
      </ul>
    </div>
  </div>

  <script>
    // Timer
    let seconds = 60;
    function updateTimer() {
      document.getElementById('timerValue').textContent = seconds < 10 ? `00:0${seconds}` : `00:${seconds}`;
      seconds = seconds > 0 ? seconds - 1 : 60;
      setTimeout(updateTimer, 1000);
    }
    updateTimer();
  </script>

  <script>
    let map, drawingManager;
    let drawnAreas = []; // {polygon, label, data{name,color,parent}}
    let selectedColor = "#2196f3";
    let loadedAreas = false;

    // ENTREGAS (placas)
    // { placa: string, area: string, order: number, status: string }
    let entregas = [];
    let entregaMarkers = [];

    // DIRECTIONS (rotas por ruas)
    let directionsService = null;
    let directionsRenderer = null;

    // Índice visual calculado pela rota (quando otimizada)
    let visualIndexFromRoute = null;

    const STATUS = {
      AGUARDANDO: "Aguardando carregamento",
      CARREGADO: "Carregado",
      EM_ROTA: "Em Rota",
      ENTREGUE: "Entregue"
    };
    function statusColor(status){
      switch(status){
        case STATUS.AGUARDANDO: return "#e53935"; // vermelho
        case STATUS.CARREGADO:  return "#ff9800"; // laranja
        case STATUS.EM_ROTA:    return "#2196f3"; // azul
        case STATUS.ENTREGUE:   return "#43a047"; // verde
        default: return "#666";
      }
    }

    function salvarTipoMapa(tipo){ localStorage.setItem('tipoMapa', tipo); }
    function lerTipoMapa(){ return localStorage.getItem('tipoMapa') || 'roadmap'; }

    function saveAreasToStorage() {
      const areasData = drawnAreas.map(area => ({
        path: area.polygon.getPath().getArray().map(ll => ({lat: ll.lat(), lng: ll.lng()})),
        color: area.data.color,
        name: area.data.name,
        parent: area.data.parent || null
      }));
      localStorage.setItem("geoareas", JSON.stringify(areasData));
    }
    function loadAreasFromStorage() {
      const saved = localStorage.getItem("geoareas");
      if (!saved) return;
      try {
        const data = JSON.parse(saved);
        data.forEach(areaObj => {
          const polygon = new google.maps.Polygon({
            paths: areaObj.path,
            fillColor: areaObj.color,
            strokeColor: areaObj.color,
            fillOpacity: 0.18,
            strokeWeight: 2,
            editable: true,
            draggable: true,
            map
          });
          handlePolygonComplete(polygon, areaObj.name, areaObj.color, areaObj.parent);
        });
      } catch(e) { console.warn('Erro carregando áreas salvas', e); }
    }

    function saveEntregas(){ localStorage.setItem("entregas", JSON.stringify(entregas)); }
    function loadEntregas(){
      const saved = localStorage.getItem("entregas");
      entregas = saved ? JSON.parse(saved) : [];
      entregas.sort((a,b)=>a.order-b.order).forEach((e,i)=>{
        e.order = i+1;
        if (!e.status) e.status = STATUS.AGUARDANDO;
      });
    }

    function getPolygonCenter(poly) {
      const path = poly.getPath().getArray();
      const bounds = new google.maps.LatLngBounds();
      path.forEach(ll=>bounds.extend(ll));
      return bounds.getCenter();
    }

    function closeAllLabels(){ drawnAreas.forEach(({label})=>{ if(label) label.close(); }); }

    function createLabelForPolygon(polygon, areaObj) {
      const center = getPolygonCenter(polygon);
      const content = document.createElement('div');
      content.className = 'custom-label-box';

      const deleteBtn = document.createElement('button');
      deleteBtn.className = "delete-area-btn";
      deleteBtn.innerHTML = "&#10005;";
      deleteBtn.title = "Excluir área";
      deleteBtn.onclick = function(e) {
        e.stopPropagation();
        const areaName = areaObj.name;
        polygon.setMap(null);
        drawnAreas = drawnAreas.filter(a => a.polygon !== polygon);
        const antes = entregas.length;
        entregas = entregas.filter(en => en.area !== areaName);
        if (antes !== entregas.length) { renumerarEntregas(); saveEntregas(); }
        saveAreasToStorage();
        setTimeout(atualizarPinsEntregas,100);
      };
      content.appendChild(deleteBtn);

      const nameDiv = document.createElement('div');
      nameDiv.className = 'area-title';
      nameDiv.textContent = areaObj.name || "(sem nome)";
      content.appendChild(nameDiv);

      if (areaObj.parent) {
        const parentDiv = document.createElement('div');
        parentDiv.className = "area-parent";
        parentDiv.textContent = "Vínculo: " + areaObj.parent;
        content.appendChild(parentDiv);
      }

      const infowindow = new google.maps.InfoWindow({ content, position: center, pixelOffset: new google.maps.Size(0,-8) });
      return infowindow;
    }

    function findParentArea(polygon) {
      const childPath = polygon.getPath().getArray();
      let parentName = null;
      drawnAreas.forEach(area => {
        if (area.polygon !== polygon) {
          const parentPoly = area.polygon;
          if (childPath.every(ll => google.maps.geometry.poly.containsLocation(ll, parentPoly))) {
            parentName = area.data.name;
          }
        }
      });
      return parentName;
    }

    function handlePolygonComplete(polygon, preName, color, preParent) {
      let areaName = preName || prompt("Nome da Área:", "") || "Área " + (drawnAreas.length+1);
      let areaColor = color || selectedColor;
      let parentName = preParent || findParentArea(polygon);

      const areaObj = { polygon, data: { name: areaName, color: areaColor, parent: parentName }, label: null };
      polygon.setOptions({ fillColor: areaColor, strokeColor: areaColor });

      const label = createLabelForPolygon(polygon, areaObj.data);
      areaObj.label = label;

      google.maps.event.addListener(polygon, 'click', function(){
        closeAllLabels();
        label.setPosition(getPolygonCenter(polygon));
        label.open(map);
      });

      function syncAfterEdit(){
        label.setPosition(getPolygonCenter(polygon));
        saveAreasToStorage();
        atualizarPinsEntregas();
      }
      google.maps.event.addListener(polygon.getPath(), 'set_at', syncAfterEdit);
      google.maps.event.addListener(polygon.getPath(), 'insert_at', syncAfterEdit);
      google.maps.event.addListener(polygon, 'dragend', syncAfterEdit);

      google.maps.event.addListener(polygon, 'map_changed', function(){
        if(!polygon.getMap()){
          const removedName = areaObj.data.name;
          drawnAreas = drawnAreas.filter(a => a.polygon !== polygon);
          const prev = entregas.length;
          entregas = entregas.filter(e => e.area !== removedName);
          if (prev !== entregas.length) { renumerarEntregas(); saveEntregas(); }
          saveAreasToStorage();
          setTimeout(atualizarPinsEntregas,100);
        }
      });

      drawnAreas.push(areaObj);
      saveAreasToStorage();
      atualizarPinsEntregas();
    }

    function clearAllAreas() {
      drawnAreas.forEach(({polygon,label}) => { if(label) label.close(); polygon.setMap(null); });
      drawnAreas = [];
      saveAreasToStorage();
      entregas = [];
      saveEntregas();
      atualizarPinsEntregas();
    }

    function posicaoDeslocada(center, index, total){
      const raio = 15 + Math.min(40, total*4);
      const ang = (2*Math.PI) * (index / Math.max(1,total));
      const cosLat = Math.cos(center.lat() * Math.PI / 180);
      const safeCos = Math.abs(cosLat) < 1e-6 ? 1e-6 : cosLat;
      const dLat = (raio/111320) * Math.cos(ang);
      const dLng = (raio/(111320*safeCos)) * Math.sin(ang);
      return new google.maps.LatLng(center.lat() + dLat, center.lng() + dLng);
    }

    function atualizarPinsEntregas(){
      // limpar pins
      entregaMarkers.forEach(m => m.setMap(null));
      entregaMarkers = [];
      // limpar índice visual de rota (será recalculado em buildRoadRoute)
      visualIndexFromRoute = null;

      if (!map) return;

      // base: não-entregues pela ordem salva
      const naoEntreguesOrdenadas = entregas.slice().sort((a,b)=>a.order-b.order).filter(e => e.status !== STATUS.ENTREGUE);

      // numeração visual padrão (sem otimização/antes da rota)
      const displayIndex = new Map();
      naoEntreguesOrdenadas.forEach((e,i)=> displayIndex.set(`${e.placa}|${e.area}`, i+1));

      // Agrupar por área p/ deslocar pins e desenhar
      const porArea = {};
      entregas.forEach(e => { (porArea[e.area] ||= []).push(e); });

      Object.keys(porArea).forEach(areaName => {
        const area = drawnAreas.find(a => a.data.name === areaName);
        if (!area) return;
        const center = getPolygonCenter(area.polygon);
        const lista = porArea[areaName].slice().sort((a,b)=>a.order-b.order);
        lista.forEach((e, i) => {
          const pos = posicaoDeslocada(center, i, lista.length);
          const color = statusColor(e.status);
          const key = `${e.placa}|${e.area}`;

          // usa índice da rota (se já existir), senão o padrão
          const idx = (visualIndexFromRoute && visualIndexFromRoute.get(key)) || displayIndex.get(key) || "";
          const labelText = (e.status === STATUS.ENTREGUE) ? "✓" : String(idx);

          const marker = new google.maps.Marker({
            position: pos,
            map,
            title: `${e.status === STATUS.ENTREGUE ? '✓' : '#'+(idx||'')} • ${e.placa} • ${e.area} • ${e.status}`,
            icon: {
              path: google.maps.SymbolPath.CIRCLE,
              fillColor: color,
              fillOpacity: 1,
              strokeColor: "#333",
              strokeWeight: 1,
              scale: 10
            },
            label: { text: labelText, fontSize: "14px", fontWeight: "700" },
            zIndex: 200 + (Number(idx) || 0)
          });
          entregaMarkers.push(marker);
        });
      });

      // constrói rota por ruas
      buildRoadRoute();
    }

    function buildRoadRoute(){
      // apaga rota atual
      if (directionsRenderer) directionsRenderer.set('directions', null);

      const optimize = document.getElementById('optimizeChk')?.checked;

      const naoEntregues = entregas.slice().sort((a,b)=>a.order-b.order).filter(e => e.status !== STATUS.ENTREGUE);
      if (naoEntregues.length < 2) { visualIndexFromRoute = null; return; }

      // centros das áreas
      const pontos = [];
      naoEntregues.forEach(e=>{
        const area = drawnAreas.find(a => a.data.name === e.area);
        if (area) pontos.push({ key: `${e.placa}|${e.area}`, latlng: getPolygonCenter(area.polygon) });
      });

      if (pontos.length < 2) { visualIndexFromRoute = null; return; }

      // Limite de 25 pontos por rota (origem+destino+waypoints)
      if (pontos.length > 25){
        // fallback: sem rota por ruas (ou poderíamos fatiar em blocos)
        visualIndexFromRoute = null;
        return;
      }

      const origin = pontos[0].latlng;
      const destination = pontos[pontos.length-1].latlng;
      const waypoints = pontos.slice(1, -1).map(p => ({ location: p.latlng, stopover: true }));

      directionsService.route({
        origin, destination, waypoints,
        travelMode: google.maps.TravelMode.DRIVING,
        optimizeWaypoints: !!optimize
      }, (result, status) => {
        if (status !== google.maps.DirectionsStatus.OK) {
          console.warn('Directions falhou:', status);
          visualIndexFromRoute = null;
          return;
        }
        directionsRenderer.setDirections(result);

        // Monta índice visual pela ordem da rota exibida
        const order = [0];
        const wpOrder = (result.routes?.[0]?.waypoint_order) || pontos.slice(1,-1).map((_,i)=>i); // identidade
        wpOrder.forEach(i => order.push(i+1));
        order.push(pontos.length-1);

        visualIndexFromRoute = new Map();
        order.forEach((idx, i) => {
          const key = pontos[idx].key;
          visualIndexFromRoute.set(key, i+1);
        });

        // Atualiza pins com a numeração da rota
        // (não mexe na ordem salva; é só visual)
        entregaMarkers.forEach(m => m.setMap(null));
        entregaMarkers = [];
        // desenha novamente
        const porArea = {};
        entregas.forEach(e => { (porArea[e.area] ||= []).push(e); });
        Object.keys(porArea).forEach(areaName => {
          const area = drawnAreas.find(a => a.data.name === areaName);
          if (!area) return;
          const center = getPolygonCenter(area.polygon);
          const lista = porArea[areaName].slice().sort((a,b)=>a.order-b.order);
          lista.forEach((e, i) => {
            const pos = posicaoDeslocada(center, i, lista.length);
            const color = statusColor(e.status);
            const key = `${e.placa}|${e.area}`;
            const idx = (visualIndexFromRoute && visualIndexFromRoute.get(key)) || "";
            const labelText = (e.status === STATUS.ENTREGUE) ? "✓" : String(idx);

            const marker = new google.maps.Marker({
              position: pos, map,
              title: `${e.status === STATUS.ENTREGUE ? '✓' : '#'+(idx||'')} • ${e.placa} • ${e.area} • ${e.status}`,
              icon: { path: google.maps.SymbolPath.CIRCLE, fillColor: color, fillOpacity: 1, strokeColor: "#333", strokeWeight: 1, scale: 10 },
              label: { text: labelText, fontSize: "14px", fontWeight: "700" },
              zIndex: 200 + (Number(idx) || 0)
            });
            entregaMarkers.push(marker);
          });
        });
      });
    }

    function setPolygonColor(color){
      selectedColor = color;
      if (drawingManager) {
        drawingManager.setOptions({
          polygonOptions: { editable:true, draggable:true, strokeColor:color, fillColor:color, fillOpacity:0.18, strokeWeight:2 }
        });
      }
    }

    document.addEventListener('DOMContentLoaded', function(){
      document.querySelectorAll('.color-circle').forEach(c=>{
        c.onclick = function(){
          document.querySelectorAll('.color-circle').forEach(x=>x.classList.remove('selected'));
          this.classList.add('selected');
          setPolygonColor(this.dataset.color);
        }
      });
      document.getElementById('customColor').addEventListener('input',function(){
        document.querySelectorAll('.color-circle').forEach(x=>x.classList.remove('selected'));
        setPolygonColor(this.value);
      });
      document.querySelector('.color-circle[data-color="#2196f3"]').classList.add('selected');

      // Recalcular rota quando alternar otimização
      document.getElementById('optimizeChk').addEventListener('change', buildRoadRoute);
    });

    function initMap() {
      const tipoMapa = lerTipoMapa();
      map = new google.maps.Map(document.getElementById('map'), {
        center: {lat: -22.5162, lng: -44.0948},
        zoom: 15,
        mapTypeId: tipoMapa,
        streetViewControl: true,
        fullscreenControl: true,
      });

      drawingManager = new google.maps.drawing.DrawingManager({
        drawingMode: null, drawingControl: false,
        polygonOptions: {
          editable: true, draggable: true, strokeColor: selectedColor, fillColor: selectedColor,
          fillOpacity: 0.18, strokeWeight: 2,
        }
      });
      drawingManager.setMap(map);

      directionsService = new google.maps.DirectionsService();
      directionsRenderer = new google.maps.DirectionsRenderer({
        map,
        suppressMarkers: true,
        polylineOptions: {
          strokeColor: "#e53935",
          strokeOpacity: 0.95,
          strokeWeight: 4
        }
      });

      document.querySelectorAll('.color-circle, #customColor').forEach(el => {
        el.addEventListener('click', () => setPolygonColor(selectedColor));
        el.addEventListener('input', () => setPolygonColor(selectedColor));
      });

      google.maps.event.addListener(drawingManager, 'polygoncomplete', function(polygon) {
        polygon.setOptions({ fillColor: selectedColor, strokeColor: selectedColor });
        handlePolygonComplete(polygon);
        drawingManager.setDrawingMode(null);
        document.getElementById('drawAreaBtn').classList.remove('active');
      });

      document.getElementById('drawAreaBtn').onclick = function() {
        setPolygonColor(selectedColor);
        drawingManager.setDrawingMode('polygon');
        this.classList.add('active');
      };
      document.getElementById('clearBtn').onclick = clearAllAreas;

      if(!loadedAreas){
        loadedAreas = true;
        google.maps.event.addListenerOnce(map, 'idle', function(){
          if(google.maps.geometry) {
            loadAreasFromStorage();
            loadEntregas();
            atualizarPinsEntregas();
          } else {
            if(!window._geoLoaded){
              window._geoLoaded = true;
              const scr = document.createElement('script');
              scr.src = "https://maps.googleapis.com/maps/api/js?key=AIzaSyB2Yir6fDl64yd4ddhLyBDkMIjpOYfpTmA&libraries=drawing,geometry&callback=initMap";
              document.body.appendChild(scr);
            }
          }
        });
      }
    }

    // ===== Modais: Placa =====
    function openModalPlaca(){
      const select = document.getElementById('areaPlaca');
      const geoareas = drawnAreas.map(a=>a.data.name).sort();
      select.innerHTML = '<option value="">Selecione...</option>' + geoareas.map(g=>`<option>${g}</option>`).join('');
      document.getElementById('placaInput').value = '';
      document.getElementById('statusPlaca').value = STATUS.AGUARDANDO;
      document.getElementById('modalPlaca').style.display = "flex";
    }
    function closeModalPlaca(){ document.getElementById('modalPlaca').style.display = "none"; }

    document.getElementById('incluirPlacaBtn').onclick = openModalPlaca;

    document.getElementById('placaForm').onsubmit = function(e){
      e.preventDefault();
      const placa = document.getElementById('placaInput').value.trim().toUpperCase();
      const area = document.getElementById('areaPlaca').value;
      const status = document.getElementById('statusPlaca').value;
      if(!placa || !area){ alert("Informe placa e geoárea."); return; }
      const order = entregas.length + 1;
      entregas.push({ placa, area, order, status });
      saveEntregas();
      atualizarPinsEntregas();
      closeModalPlaca();
    };

    // ===== Modal: Gestão (drag & drop + status) =====
    const modalGestao = document.getElementById('modalGestao');
    const entregasList = document.getElementById('entregasList');

    function openModalGestao(){
      renderEntregasList();
      modalGestao.style.display = 'flex';
    }
    function closeModalGestao(){ modalGestao.style.display = 'none'; }

    document.getElementById('gerenciarOrdemBtn').onclick = openModalGestao;

    function renderEntregasList(){
      const arr = [...entregas].sort((a,b)=>a.order-b.order);
      const naoEntregues = arr.filter(e => e.status !== STATUS.ENTREGUE);
      const idxVisual = new Map();
      naoEntregues.forEach((e,i)=> idxVisual.set(`${e.placa}|${e.area}`, i+1));

      entregasList.innerHTML = '';
      arr.forEach((e) => {
        const li = document.createElement('li');
        li.className = 'drag-item';
        li.draggable = true;
        li.dataset.key = e.placa + '|' + e.area;

        // se já tiver visualIndexFromRoute (rota otimizada), use-o; senão use idxVisual padrão
        const key = `${e.placa}|${e.area}`;
        const numero = (visualIndexFromRoute && visualIndexFromRoute.get(key)) ?? idxVisual.get(key);

        const pill = (e.status === STATUS.ENTREGUE)
          ? `<span class="pill pill-ok">✓</span>`
          : `<span class="pill">#${numero ?? ''}</span>`;

        li.innerHTML = `
          <div class="left">
            <span class="handle">☰</span>
            ${pill}
            <div><b>${e.placa}</b> <span style="color:#666">• ${e.area}</span></div>
          </div>
          <div style="display:flex; gap:8px; align-items:center;">
            <select class="status-select">
              <option ${e.status===STATUS.AGUARDANDO?'selected':''}>${STATUS.AGUARDANDO}</option>
              <option ${e.status===STATUS.CARREGADO?'selected':''}>${STATUS.CARREGADO}</option>
              <option ${e.status===STATUS.EM_ROTA?'selected':''}>${STATUS.EM_ROTA}</option>
              <option ${e.status===STATUS.ENTREGUE?'selected':''}>${STATUS.ENTREGUE}</option>
            </select>
            <button class="danger-btn" onclick="removerEntrega('${e.placa.replace(/'/g,"\\'")}', '${e.area.replace(/'/g,"\\'")}')">Excluir</button>
          </div>
        `;
        entregasList.appendChild(li);
      });
      wireDragAndDrop();
      wireStatusChanges();
    }

    function wireStatusChanges(){
      entregasList.querySelectorAll('.drag-item').forEach(li=>{
        const select = li.querySelector('.status-select');
        select.addEventListener('change', () => {
          const [placa, area] = li.dataset.key.split('|');
          const obj = entregas.find(x => x.placa === placa && x.area === area);
          if (obj){
            obj.status = select.value;
            saveEntregas();
            renderEntregasList();
            atualizarPinsEntregas();
          }
        });
      });
    }

    function removerEntrega(placa, area){
      entregas = entregas.filter(e => !(e.placa === placa && e.area === area));
      renumerarEntregas();
      saveEntregas();
      renderEntregasList();
      atualizarPinsEntregas();
    }

    function renumerarEntregas(){
      entregas.sort((a,b)=>a.order-b.order).forEach((e,i)=> e.order = i+1);
    }

    function wireDragAndDrop(){
      let dragEl = null;
      entregasList.querySelectorAll('.drag-item').forEach(item=>{
        item.addEventListener('dragstart', (ev)=>{
          dragEl = item;
          ev.dataTransfer.effectAllowed = 'move';
        });
        item.addEventListener('dragover', (ev)=>{
          ev.preventDefault();
          const bounding = item.getBoundingClientRect();
          const offset = ev.clientY - bounding.top;
          const before = offset < bounding.height/2;
          entregasList.insertBefore(dragEl, before ? item : item.nextSibling);
        });
        item.addEventListener('dragend', ()=> { dragEl = null; });
      });
    }

    function salvarReordenacao(){
      const novos = [];
      entregasList.querySelectorAll('.drag-item').forEach((li, idx)=>{
        const [placa, area] = li.dataset.key.split('|');
        const obj = entregas.find(e => e.placa === placa && e.area === area);
        if (obj) { obj.order = idx + 1; novos.push(obj); }
      });
      entregas = novos;
      saveEntregas();
      closeModalGestao();
      atualizarPinsEntregas();
    }

    // Sidebar responsivo
    const menuToggle = document.getElementById('menu-toggle');
    const sidebar = document.getElementById('sidebar');
    menuToggle.addEventListener('click', function () { sidebar.classList.toggle('active'); });
    document.addEventListener('click', function (e) {
      if (window.innerWidth <= 900 && sidebar.classList.contains('active') && !sidebar.contains(e.target) && !menuToggle.contains(e.target)) {
        sidebar.classList.remove('active');
      }
    });
  </script>

  <!-- Google Maps (habilite também a Directions API no console do Google) -->
  <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyB2Yir6fDl64yd4ddhLyBDkMIjpOYfpTmA&libraries=drawing,geometry&callback=initMap" async defer></script>

  <script src="darkmode.js"></script>
</body>
<footer class="footer">
  <div class="footer-content" style="display: flex; justify-content: space-between; align-items: center;">
    <div class="footer-logo-group">
      <img src="assets/syncnex-logo-64x64.png" alt="Logo SyncNex" class="footer-logo" />
      <div>
        <span class="footer-title">SyncNex &copy; 2025</span>
        <span class="footer-slogan">Conectando eficiência ao seu negócio</span>
      </div>
    </div>
    <nav class="footer-nav">
      <a href="#">Sobre Nós</a>
      <a href="#">Contato</a>
      <a href="#">Política de Privacidade</a>
      <a href="#">Termos de Uso</a>
    </nav>
      <span class="versao">Versão <b>V1.4.0</b></span>
    </div>
  </div>
</footer>
</html>
