<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SyncNex - CSN</title>
  <link rel="icon" type="image/png" href="assets/syncnex-favicon.png">
  <style>
    html, body { height: 100%; margin: 0; padding: 0; font-family: Roboto, Arial, sans-serif; }
    #map { width: 100vw; height: 100vh; position: absolute; left: 200px; top: 0; z-index: 1; }
    .custom-controls { position: absolute; top: 10px; left: 500px; z-index: 5; display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    .custom-controls button, .custom-controls input[type="color"], .custom-controls label {
      padding: 8px 12px; background: #fff; border: 1px solid #ddd; border-radius: 6px; font-size: 14px; cursor: pointer; font-weight: 600; box-shadow: 0 2px 6px #0001;
    }
    .custom-controls button.active, .custom-controls button:hover { background: #ececec; }
    .color-picker { display: flex; align-items: center; gap: 4px; }
    .color-circle { width: 22px; height: 22px; border-radius: 50%; border: 2px solid #ddd; cursor: pointer; display: inline-block; }
    .color-circle.selected { border: 3px solid #2196f3; }
    .custom-label-box {
      background: #fff; border-radius: 12px; padding: 6px 16px 14px 16px; box-shadow: 0 2px 10px #0002; border: 1px solid #eee;
      position: relative; min-width: 80px; display: flex; flex-direction: column; align-items: center; font-size: 1rem;
    }
    .custom-label-box .delete-area-btn { position: absolute; top: 2px; right: 7px; color: #b21c1c; background: transparent; border: none; font-size: 20px; cursor: pointer; }
    .custom-label-box .area-title { margin: 8px 0 3px 0; font-weight: 600; background: #e9f7fa; padding: 3px 10px; border-radius: 6px; border: 1px solid #b8d0db; color: #118; }
    .custom-label-box .area-parent { font-size: 12px; color: #757575; margin-top: 2px; }
    .modal-bg { display:none; position:fixed; z-index:1001; left:0; top:0; width:100vw; height:100vh; background:rgba(0,0,0,0.24); align-items:center; justify-content:center; }
    .modal { background:#fff; border-radius:10px; padding:22px 18px; min-width:340px; box-shadow:0 8px 40px #0005; position:relative; color:#000; max-height:80vh; overflow:auto; }
    .modal h3 { margin-top:0; }
    .modal-close { position:absolute; top:10px; right:14px; font-size:20px; background:none; border:none; color:#b21c1c; cursor:pointer; }
    .modal label { display:block; margin:10px 0 4px; font-weight:500; }
    .modal select, .modal input[type="text"] { width:90%; font-size:1rem; padding:6px 8px; }
    .drag-list { list-style:none; padding:0; margin:8px 0; }
    .drag-item { display:flex; align-items:center; justify-content:space-between; gap:10px; padding:10px 12px; border:1px solid #e1e1e1; border-radius:8px; background:#fff; margin-bottom:8px; cursor:grab; }
    .drag-item .left { display:flex; align-items:center; gap:10px; }
    .handle { font-size:18px; user-select:none; }
    .pill { background:#eef4ff; border:1px solid #cddfff; padding:2px 8px; border-radius:999px; font-size:.9em; color:#23488b; }
    .pill-ok { background:#e6f7ec; border:1px solid #bfe7c9; color:#256c30; }
    .danger-btn { background:#c32c2c; color:#fff; padding:6px 10px; border:none; border-radius:6px; cursor:pointer; }
    .ok-btn { background:#2196f3; color:#fff; padding:8px 18px; border:none; border-radius:6px; cursor:pointer; font-weight:bold; }
    .timer-bar { position: fixed; right: 0; top: 0; font-size: 14px; color: #444; z-index: 10; background: #fafafadb; padding: 2px 8px; border-radius: 0 0 8px 8px; border-bottom: 1px solid #ddd; }
    .sidebar { position: absolute; left: 0; top: 0; width: 200px; height: 100vh; background: #0a1020f0; color: #fff; z-index: 20; }
    .sidebar .logo-csn { width: 160px; display:block; margin:14px auto; }
    .sidebar .menu { list-style:none; padding:0 14px; }
    .sidebar .menu li a{ color:#cdd7ff; text-decoration:none; display:block; padding:6px 0; }
    .footer { position: fixed; left: 0; bottom: 0; width: 100vw; z-index: 99; background: rgba(10,16,30,0.94); color: #fff; }
  </style>
</head>
<body>
  <div class="sidebar">
    <img src="/assets/logo-csn.png" class="logo-csn" alt="Logo" />
    <ul class="menu">
      <li><a href="#">Mapa</a></li>
      <!-- demais itens… -->
    </ul>
  </div>

  <div class="timer-bar">Próxima atualização em: <span id="timerValue">01:00</span></div>

  <div class="custom-controls">
    <div class="color-picker" title="Cor da área">
      <span class="color-circle" data-color="#2196f3" style="background:#2196f3;"></span>
      <span class="color-circle" data-color="#43a047" style="background:#43a047;"></span>
      <span class="color-circle" data-color="#ff9800" style="background:#ff9800;"></span>
      <span class="color-circle" data-color="#e53935" style="background:#e53935;"></span>
      <input type="color" id="customColor" value="#2196f3" style="width:34px;height:26px;">
    </div>
    <button id="drawAreaBtn">Desenhar Área</button>
    <button id="clearAreasBtn">Limpar Áreas</button>

    <!-- Ruas internas -->
    <button id="drawRoadBtn">Desenhar Rua</button>
    <button id="clearRoadsBtn">Limpar Ruas</button>

    <!-- Entregas -->
    <button id="incluirPlacaBtn" style="background:#2969b0; color:#fff;">Incluir Placa</button>
    <button id="gerenciarOrdemBtn" style="background:#5c6bc0; color:#fff;">Gerenciar Entregas</button>
  </div>

  <div id="map"></div>

  <!-- Modal: Incluir Placa -->
  <div class="modal-bg" id="modalPlaca">
    <div class="modal">
      <button class="modal-close" onclick="closeModalPlaca()">&times;</button>
      <h3>Nova Placa de Entrega</h3>
      <form id="placaForm" autocomplete="off">
        <label>Placa</label>
        <input id="placaInput" type="text" placeholder="ABC1D23" required />
        <label>Geoárea</label>
        <select id="areaPlaca" required><option value="">Selecione...</option></select>
        <label>Status</label>
        <select id="statusPlaca" required>
          <option>Aguardando carregamento</option>
          <option>Carregado</option>
          <option>Em Rota</option>
          <option>Entregue</option>
        </select>
        <div style="margin-top:15px;">
          <button type="submit" class="ok-btn">Salvar</button>
        </div>
      </form>
    </div>
  </div>

  <!-- Modal: Gerenciar -->
  <div class="modal-bg" id="modalGestao">
    <div class="modal" style="min-width:520px;">
      <button class="modal-close" onclick="closeModalGestao()">&times;</button>
      <h3>Entregas (arraste para reordenar)</h3>
      <ul id="entregasList" class="drag-list"></ul>
      <div style="margin-top:10px; display:flex; gap:10px; justify-content:flex-end;">
        <button class="ok-btn" onclick="salvarReordenacao()">Concluir</button>
      </div>
    </div>
  </div>

  <script>
    // ===== Timer
    let seconds = 60;
    (function updateTimer(){
      document.getElementById('timerValue').textContent = seconds < 10 ? `00:0${seconds}` : `00:${seconds}`;
      seconds = seconds > 0 ? seconds - 1 : 60;
      setTimeout(updateTimer, 1000);
    })();
  </script>

  <script>
    // ====== Estado
    let map, drawingManager;
    let selectedColor = "#2196f3";
    let drawnAreas = [];     // {polygon, label, data{name,color,parent}}
    let roads = [];          // [{polyline, path:[{lat,lng}]}]
    let roadGraph = null;    // {nodes: Map(id->{lat,lng}), adj: Map(id->[{to, w}])}
    let entregaMarkers = [];
    let routePolyline = null;

    // ENTREGAS
    // { placa, area, order, status }
    let entregas = [];

    const STATUS = {
      AGUARDANDO: "Aguardando carregamento",
      CARREGADO: "Carregado",
      EM_ROTA: "Em Rota",
      ENTREGUE: "Entregue"
    };
    const PI = Math.PI;

    // ===== Persistência
    function saveAreas(){ localStorage.setItem("geoareas", JSON.stringify(drawnAreas.map(a=>({
      path: a.polygon.getPath().getArray().map(ll=>({lat:ll.lat(),lng:ll.lng()})),
      color: a.data.color, name: a.data.name, parent: a.data.parent||null
    })))); }
    function loadAreas(){
      const raw = localStorage.getItem("geoareas"); if(!raw) return;
      JSON.parse(raw).forEach(obj=>{
        const poly = new google.maps.Polygon({
          paths: obj.path, fillColor: obj.color, strokeColor: obj.color, fillOpacity: .18, strokeWeight: 2,
          editable:true, draggable:true, map
        });
        handlePolygonComplete(poly, obj.name, obj.color, obj.parent);
      });
    }
    function saveRoads(){
      const data = roads.map(r=>r.polyline.getPath().getArray().map(ll=>({lat:ll.lat(),lng:ll.lng()})));
      localStorage.setItem("ruas", JSON.stringify(data));
    }
    function loadRoads(){
      const raw = localStorage.getItem("ruas"); if(!raw) return;
      JSON.parse(raw).forEach(path=>{
        const polyline = new google.maps.Polyline({
          path, strokeColor:"#ff1744", strokeWeight:3, strokeOpacity:0.9, editable:true, map
        });
        hookRoadPolyline(polyline);
        roads.push({polyline});
      });
      rebuildRoadGraph();
    }
    function saveEntregas(){ localStorage.setItem("entregas", JSON.stringify(entregas)); }
    function loadEntregas(){
      const raw = localStorage.getItem("entregas");
      entregas = raw ? JSON.parse(raw) : [];
      entregas.sort((a,b)=>a.order-b.order).forEach((e,i)=>{ e.order=i+1; if(!e.status) e.status=STATUS.AGUARDANDO; });
    }

    // ===== Util
    function setPolygonColor(color){
      selectedColor = color;
      if (drawingManager) {
        drawingManager.setOptions({ polygonOptions: {editable:true,draggable:true,strokeColor:color,fillColor:color,fillOpacity:.18,strokeWeight:2}});
      }
    }
    document.addEventListener('DOMContentLoaded',()=>{
      document.querySelectorAll('.color-circle').forEach(c=>{
        c.onclick=()=>{ document.querySelectorAll('.color-circle').forEach(x=>x.classList.remove('selected')); c.classList.add('selected'); setPolygonColor(c.dataset.color); }
      });
      document.getElementById('customColor').addEventListener('input',e=>{
        document.querySelectorAll('.color-circle').forEach(x=>x.classList.remove('selected')); setPolygonColor(e.target.value);
      });
      document.querySelector('.color-circle[data-color="#2196f3"]').classList.add('selected');
    });

    function getPolygonCenter(poly){
      const b = new google.maps.LatLngBounds();
      poly.getPath().forEach(ll=>b.extend(ll));
      return b.getCenter();
    }
    function haversine(a,b){
      const R=6371000, dLat=(b.lat-a.lat)*PI/180, dLng=(b.lng-a.lng)*PI/180;
      const s1=Math.sin(dLat/2), s2=Math.sin(dLng/2);
      const q=s1*s1 + Math.cos(a.lat*PI/180)*Math.cos(b.lat*PI/180)*s2*s2;
      return 2*R*Math.asin(Math.min(1,Math.sqrt(q)));
    }
    function posicaoDeslocada(center, i, n){
      const raio = 15 + Math.min(40, n*4);
      const ang = (2*PI) * (i / Math.max(1,n));
      const cosLat = Math.cos(center.lat()*PI/180); const safe = Math.abs(cosLat)<1e-6?1e-6:cosLat;
      const dLat = (raio/111320) * Math.cos(ang); const dLng = (raio/(111320*safe)) * Math.sin(ang);
      return new google.maps.LatLng(center.lat()+dLat, center.lng()+dLng);
    }

    // ===== Áreas
    function closeAllLabels(){ drawnAreas.forEach(({label})=>label&&label.close()); }
    function createLabelForPolygon(polygon, areaObj){
      const center = getPolygonCenter(polygon);
      const content = document.createElement('div'); content.className='custom-label-box';
      const del = document.createElement('button'); del.className='delete-area-btn'; del.innerHTML='&times;'; del.title="Excluir área";
      del.onclick=(e)=>{ e.stopPropagation(); const name=areaObj.name; polygon.setMap(null); drawnAreas=drawnAreas.filter(a=>a.polygon!==polygon);
        // apaga entregas da área
        const before=entregas.length; entregas=entregas.filter(x=>x.area!==name); if(before!==entregas.length){ renumerar(); saveEntregas(); }
        saveAreas(); atualizarPinsERota();
      };
      content.appendChild(del);
      const title=document.createElement('div'); title.className='area-title'; title.textContent=areaObj.name||'(sem nome)'; content.appendChild(title);
      if(areaObj.parent){ const p=document.createElement('div'); p.className='area-parent'; p.textContent='Vínculo: '+areaObj.parent; content.appendChild(p); }
      return new google.maps.InfoWindow({content, position:center, pixelOffset:new google.maps.Size(0,-8)});
    }
    function findParentArea(polygon){
      const child = polygon.getPath().getArray();
      let parent=null;
      drawnAreas.forEach(a=>{
        if(a.polygon!==polygon){
          if(child.every(ll=>google.maps.geometry.poly.containsLocation(ll, a.polygon))) parent=a.data.name;
        }
      });
      return parent;
    }
    function handlePolygonComplete(polygon, preName, color, preParent){
      let name = preName || prompt("Nome da Área:", "") || "Área " + (drawnAreas.length+1);
      let areaColor = color || selectedColor;
      let parent = preParent || findParentArea(polygon);

      const areaObj = { polygon, data:{name, color:areaColor, parent}, label:null };
      polygon.setOptions({ fillColor: areaColor, strokeColor: areaColor });
      const label = createLabelForPolygon(polygon, areaObj.data); areaObj.label=label;

      google.maps.event.addListener(polygon, 'click', ()=>{ closeAllLabels(); label.setPosition(getPolygonCenter(polygon)); label.open(map); });
      function sync(){ label.setPosition(getPolygonCenter(polygon)); saveAreas(); atualizarPinsERota(); }
      google.maps.event.addListener(polygon.getPath(),'set_at',sync);
      google.maps.event.addListener(polygon.getPath(),'insert_at',sync);
      google.maps.event.addListener(polygon,'dragend',sync);
      google.maps.event.addListener(polygon,'map_changed',()=>{ if(!polygon.getMap()){ drawnAreas=drawnAreas.filter(a=>a.polygon!==polygon); saveAreas(); atualizarPinsERota(); } });

      drawnAreas.push(areaObj); saveAreas(); atualizarPinsERota();
    }

    // ===== Ruas (desenho e grafo)
    function hookRoadPolyline(pl){
      function sync(){ saveRoads(); rebuildRoadGraph(); atualizarPinsERota(); }
      google.maps.event.addListener(pl.getPath(),'set_at',sync);
      google.maps.event.addListener(pl.getPath(),'insert_at',sync);
      google.maps.event.addListener(pl,'dragend',sync);
      google.maps.event.addListener(pl,'map_changed',()=>{ if(!pl.getMap()){ roads=roads.filter(r=>r.polyline!==pl); saveRoads(); rebuildRoadGraph(); atualizarPinsERota(); } });
    }

    function rebuildRoadGraph(){
      // nodes indexados por string "lat,lng" com tolerância
      const tol = 1e-7;
      function keyOf(ll){ return (Math.round(ll.lat()*1e7)/1e7)+','+(Math.round(ll.lng()*1e7)/1e7); }
      const nodes = new Map(); const coords = new Map(); let idSeq=0;
      function getId(ll){ const k=keyOf(ll); if(nodes.has(k)) return nodes.get(k); const id=String(idSeq++); nodes.set(k,id); coords.set(id,{lat:ll.lat(),lng:ll.lng()}); return id; }
      const adj = new Map();
      function addEdge(a,b,w){ if(!adj.has(a)) adj.set(a,[]); if(!adj.has(b)) adj.set(b,[]); adj.get(a).push({to:b,w}); adj.get(b).push({to:a,w}); }

      roads.forEach(r=>{
        const arr = r.polyline.getPath().getArray();
        for(let i=0;i<arr.length-1;i++){
          const A=arr[i], B=arr[i+1];
          const idA=getId(A), idB=getId(B);
          const w=haversine({lat:A.lat(),lng:A.lng()},{lat:B.lat(),lng:B.lng()});
          addEdge(idA,idB,w);
        }
      });
      roadGraph = {nodes:coords, adj};
    }

    // Dijkstra simples
    function shortestPath(fromLatLng, toLatLng){
      if(!roadGraph || roadGraph.nodes.size===0) return null;

      // encontra nó mais próximo (snap)
      function nearestNode(p){
        let best=null, bestD=Infinity, bestId=null;
        roadGraph.nodes.forEach((c,id)=>{
          const d = haversine({lat:p.lat(),lng:p.lng()}, c);
          if(d<bestD){ bestD=d; bestId=id; best=c; }
        });
        // limite opcional de encaixe: 150m (ajuste se quiser)
        return (bestD<=150) ? {id:bestId, coord:best, dist:bestD} : null;
      }
      const nFrom = nearestNode(fromLatLng);
      const nTo   = nearestNode(toLatLng);
      if(!nFrom || !nTo) return null;

      const N = roadGraph.nodes.size;
      const dist = new Map(); const prev = new Map(); const done = new Set();
      roadGraph.nodes.forEach((_,id)=>dist.set(id,Infinity));
      dist.set(nFrom.id,0);

      // min-heap simples por laço (N pequeno)
      function extractMin(){
        let best=null, bestD=Infinity;
        dist.forEach((d,id)=>{ if(!done.has(id) && d<bestD){bestD=d; best=id;} });
        return best;
      }

      while(true){
        const u = extractMin();
        if(!u || u===nTo.id) break;
        done.add(u);
        const edges = roadGraph.adj.get(u)||[];
        edges.forEach(({to,w})=>{
          if(done.has(to)) return;
          const alt = dist.get(u)+w;
          if(alt<dist.get(to)){ dist.set(to,alt); prev.set(to,u); }
        });
      }

      // reconstrói caminho
      const pathIds = [];
      let cur = nTo.id;
      if(!prev.has(cur) && cur!==nFrom.id) return null;
      while(cur){ pathIds.unshift(cur); if(cur===nFrom.id) break; cur = prev.get(cur); }
      // coords
      const path = pathIds.map(id=> roadGraph.nodes.get(id));
      // adiciona pontos de snap (origem/destino reais) nas extremidades
      path.unshift({lat: fromLatLng.lat(), lng: fromLatLng.lng()});
      path.push({lat: toLatLng.lat(), lng: toLatLng.lng()});
      return path;
    }

    // ===== Pins e Rota
    function atualizarPinsERota(){
      // limpa pins
      entregaMarkers.forEach(m=>m.setMap(null)); entregaMarkers=[];

      // base: não-entregues
      const pendentes = entregas.slice().sort((a,b)=>a.order-b.order).filter(e=>e.status!==STATUS.ENTREGUE);

      // índice visual simples (1..N) para pendentes
      const idx = new Map(); pendentes.forEach((e,i)=>idx.set(`${e.placa}|${e.area}`, i+1));

      // agrupar por área
      const porArea = {};
      entregas.forEach(e=>{ (porArea[e.area] ||= []).push(e); });

      Object.keys(porArea).forEach(areaName=>{
        const area = drawnAreas.find(a=>a.data.name===areaName); if(!area) return;
        const center = getPolygonCenter(area.polygon);
        const lista = porArea[areaName].slice().sort((a,b)=>a.order-b.order);
        lista.forEach((e,i)=>{
          const pos = posicaoDeslocada(center, i, lista.length);
          const color = statusColor(e.status);
          const key = `${e.placa}|${e.area}`;
          const labelText = (e.status===STATUS.ENTREGUE) ? "✓" : String(idx.get(key)||"");
          const marker = new google.maps.Marker({
            position: pos, map,
            title: `${labelText==='✓'?'✓':'#'+labelText} • ${e.placa} • ${e.area} • ${e.status}`,
            icon: { path: google.maps.SymbolPath.CIRCLE, fillColor: color, fillOpacity: 1, strokeColor: "#333", strokeWeight: 1, scale: 10 },
            label: { text: labelText, fontSize: "14px", fontWeight: "700" },
            zIndex: 200 + (Number(idx.get(key))||0)
          });
          entregaMarkers.push(marker);
        });
      });

      // desenha rota no grafo
      drawRouteOnRoadGraph(pendentes);
    }

    function drawRouteOnRoadGraph(pendentes){
      if(routePolyline){ routePolyline.setMap(null); routePolyline=null; }
      if(pendentes.length<2){ return; }

      const centers = pendentes.map(e=>{
        const area = drawnAreas.find(a=>a.data.name===e.area);
        return area ? getPolygonCenter(area.polygon) : null;
      }).filter(Boolean);

      if(centers.length<2) return;

      // concatena menor caminho entre pares consecutivos
      let finalPath = [];
      for(let i=0;i<centers.length-1;i++){
        const from = centers[i], to = centers[i+1];
        const path = shortestPath(from, to);
        if(path){ // tem rua interna
          if(finalPath.length) path.shift(); // evita duplicar o nó de junção
          finalPath = finalPath.concat(path);
        } else {
          // fallback: reta
          if(finalPath.length) finalPath.push({lat: from.lat(), lng: from.lng()});
          finalPath.push({lat: to.lat(), lng: to.lng()});
        }
      }

      routePolyline = new google.maps.Polyline({
        path: finalPath.map(p=>new google.maps.LatLng(p.lat,p.lng)),
        strokeColor: "#e53935", strokeOpacity: .95, strokeWeight: 4, geodesic: true, map
      });
    }

    // ===== Entregas: UI
    function renumerar(){ entregas.sort((a,b)=>a.order-b.order).forEach((e,i)=>e.order=i+1); }
    function openModalPlaca(){
      const select = document.getElementById('areaPlaca');
      const geoareas = drawnAreas.map(a=>a.data.name).sort();
      select.innerHTML = '<option value="">Selecione...</option>' + geoareas.map(g=>`<option>${g}</option>`).join('');
      document.getElementById('placaInput').value=''; document.getElementById('statusPlaca').value=STATUS.AGUARDANDO;
      document.getElementById('modalPlaca').style.display='flex';
    }
    function closeModalPlaca(){ document.getElementById('modalPlaca').style.display='none'; }
    function openModalGestao(){ renderEntregasList(); document.getElementById('modalGestao').style.display='flex'; }
    function closeModalGestao(){ document.getElementById('modalGestao').style.display='none'; }

    function renderEntregasList(){
      const ul = document.getElementById('entregasList'); ul.innerHTML='';
      const arr = entregas.slice().sort((a,b)=>a.order-b.order);
      const pend = arr.filter(e=>e.status!==STATUS.ENTREGUE);
      const idx = new Map(); pend.forEach((e,i)=>idx.set(`${e.placa}|${e.area}`, i+1));
      arr.forEach(e=>{
        const li=document.createElement('li'); li.className='drag-item'; li.draggable=true; li.dataset.key=e.placa+'|'+e.area;
        const key = `${e.placa}|${e.area}`; const num = idx.get(key);
        const pill = (e.status===STATUS.ENTREGUE) ? `<span class="pill pill-ok">✓</span>` : `<span class="pill">#${num??''}</span>`;
        li.innerHTML = `
          <div class="left">
            <span class="handle">☰</span>
            ${pill}
            <div><b>${e.placa}</b> <span style="color:#666">• ${e.area}</span></div>
          </div>
          <div style="display:flex; gap:8px; align-items:center;">
            <select class="status-select">
              <option ${e.status===STATUS.AGUARDANDO?'selected':''}>${STATUS.AGUARDANDO}</option>
              <option ${e.status===STATUS.CARREGADO?'selected':''}>${STATUS.CARREGADO}</option>
              <option ${e.status===STATUS.EM_ROTA?'selected':''}>${STATUS.EM_ROTA}</option>
              <option ${e.status===STATUS.ENTREGUE?'selected':''}>${STATUS.ENTREGUE}</option>
            </select>
            <button class="danger-btn">Excluir</button>
          </div>`;
        ul.appendChild(li);
      });
      // eventos
      ul.querySelectorAll('.danger-btn').forEach(btn=>{
        btn.onclick=()=>{
          const li=btn.closest('.drag-item'); const [placa,area]=li.dataset.key.split('|');
          entregas = entregas.filter(e=>!(e.placa===placa && e.area===area)); renumerar(); saveEntregas(); renderEntregasList(); atualizarPinsERota();
        };
      });
      ul.querySelectorAll('.status-select').forEach(sel=>{
        sel.onchange=()=>{
          const li=sel.closest('.drag-item'); const [placa,area]=li.dataset.key.split('|');
          const obj = entregas.find(e=>e.placa===placa && e.area===area); if(obj){ obj.status = sel.value; saveEntregas(); renderEntregasList(); atualizarPinsERota(); }
        };
      });
      wireDragAndDrop(ul);
    }
    function wireDragAndDrop(ul){
      let dragEl=null;
      ul.querySelectorAll('.drag-item').forEach(item=>{
        item.addEventListener('dragstart', ev=>{ dragEl=item; ev.dataTransfer.effectAllowed='move'; });
        item.addEventListener('dragover', ev=>{
          ev.preventDefault();
          const b=item.getBoundingClientRect(); const before=(ev.clientY-b.top)<(b.height/2);
          ul.insertBefore(dragEl, before?item:item.nextSibling);
        });
        item.addEventListener('dragend', ()=>{ dragEl=null; });
      });
    }
    function salvarReordenacao(){
      const novos=[]; document.querySelectorAll('#entregasList .drag-item').forEach((li,idx)=>{
        const [placa,area]=li.dataset.key.split('|'); const obj=entregas.find(e=>e.placa===placa && e.area===area); if(obj){ obj.order=idx+1; novos.push(obj); }
      });
      entregas = novos; saveEntregas(); closeModalGestao(); atualizarPinsERota();
    }

    // ===== Init Map e botões
    function initMap(){
      map = new google.maps.Map(document.getElementById('map'), {
        center:{lat:-22.5162, lng:-44.0948}, zoom:15, mapTypeId:'satellite', streetViewControl:true, fullscreenControl:true
      });

      drawingManager = new google.maps.drawing.DrawingManager({
        drawingMode: null, drawingControl:false,
        polygonOptions:{ editable:true, draggable:true, strokeColor:selectedColor, fillColor:selectedColor, fillOpacity:.18, strokeWeight:2 },
        polylineOptions:{ editable:true, strokeColor:'#ff1744', strokeWeight:3, strokeOpacity:.9 }
      });
      drawingManager.setMap(map);

      // eventos desenho
      google.maps.event.addListener(drawingManager,'polygoncomplete',poly=>{
        poly.setOptions({fillColor:selectedColor,strokeColor:selectedColor}); handlePolygonComplete(poly);
        drawingManager.setDrawingMode(null); document.getElementById('drawAreaBtn').classList.remove('active');
      });
      google.maps.event.addListener(drawingManager,'polylinecomplete',pl=>{
        hookRoadPolyline(pl); roads.push({polyline:pl}); saveRoads(); rebuildRoadGraph(); atualizarPinsERota();
        drawingManager.setDrawingMode(null); document.getElementById('drawRoadBtn').classList.remove('active');
      });

      // Botões
      document.getElementById('drawAreaBtn').onclick=function(){ setPolygonColor(selectedColor); drawingManager.setDrawingMode('polygon'); this.classList.add('active'); };
      document.getElementById('clearAreasBtn').onclick=function(){
        drawnAreas.forEach(a=>{ if(a.label) a.label.close(); a.polygon.setMap(null); }); drawnAreas=[]; saveAreas();
        // também limpa entregas (opcional, aqui não limpo)
        atualizarPinsERota();
      };

      document.getElementById('drawRoadBtn').onclick=function(){ drawingManager.setDrawingMode('polyline'); this.classList.add('active'); };
      document.getElementById('clearRoadsBtn').onclick=function(){
        roads.forEach(r=>r.polyline.setMap(null)); roads=[]; saveRoads(); rebuildRoadGraph(); atualizarPinsERota();
      };

      document.getElementById('incluirPlacaBtn').onclick=openModalPlaca;
      document.getElementById('gerenciarOrdemBtn').onclick=openModalGestao;

      // persistência
      loadAreas(); loadRoads(); loadEntregas(); atualizarPinsERota();

      // modal eventos
      document.getElementById('placaForm').onsubmit=function(e){
        e.preventDefault();
        const placa=document.getElementById('placaInput').value.trim().toUpperCase();
        const area=document.getElementById('areaPlaca').value; const status=document.getElementById('statusPlaca').value;
        if(!placa||!area){ alert('Informe placa e geoárea.'); return; }
        entregas.push({placa,area,order:entregas.length+1,status}); saveEntregas(); atualizarPinsERota(); closeModalPlaca();
      };
      document.querySelectorAll('.modal-bg').forEach(bg=>bg.addEventListener('click',e=>{ if(e.target===bg) bg.style.display='none'; }));

      // popular combo de áreas ao abrir o modal
      document.getElementById('incluirPlacaBtn').addEventListener('click',()=>{
        const select = document.getElementById('areaPlaca');
        const geoareas = drawnAreas.map(a=>a.data.name).sort();
        select.innerHTML = '<option value="">Selecione...</option>' + geoareas.map(g=>`<option>${g}</option>`).join('');
      });
    }
    window.initMap = initMap;
  </script>

  <!-- Google Maps (drawing+geometry) -->
  <script src="https://maps.googleapis.com/maps/api/js?key=YOUR_API_KEY_HERE&libraries=drawing,geometry&callback=initMap" async defer></script>
</body>
</html>
